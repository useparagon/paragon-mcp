import Ajv from "ajv";
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";

import { JsonResponseError, UserNotConnectedError } from "./errors";
import {
  ExtendedTool,
  ProxyApiRequestToolArgs,
  TransportPayload,
} from "./type";
import {
  decodeJwt,
  generateSetupLink,
  performAction,
  getTools,
  performOpenApiAction,
  performProxyApiRequest,
  envs,
} from "./utils";

import allowedTools from "./allowedTools";

const ajv = new Ajv({ allErrors: true, strict: false });

/**
 * Get tools from ActionKit API, append extraTools, and filter by integrations if specified in the environment variables
 * @param jwt - Paragon User Token
 * @param extraTools - Additional tools, e.g. those generated by OpenAPI specs
 */
async function getAndProcessTools(
  jwt: string,
  extraTools: Array<ExtendedTool> = [],
  selectedIntegrations: string[] = []
): Promise<Array<ExtendedTool>> {
  const dynamicTools = await getTools(jwt);
  const allTools = [...dynamicTools, ...extraTools].filter((tool, index, self) => 
    index === self.findIndex((t) => t.name === tool.name)
  );

  const instanceIntegrations = envs.LIMIT_TO_INTEGRATIONS && envs.LIMIT_TO_INTEGRATIONS.length > 0 ? envs.LIMIT_TO_INTEGRATIONS : [];

  let availableIntegrations = [];
  if(selectedIntegrations.length > 1) {
    availableIntegrations = selectedIntegrations.filter(z => instanceIntegrations.includes(z));
  } else {
    availableIntegrations = instanceIntegrations;
  }


  return allTools.filter((tool) => {
    let keep = true;
    if (envs.LIMIT_TO_TOOLS && envs.LIMIT_TO_TOOLS.length > 0) {
      keep = keep && envs.LIMIT_TO_TOOLS.includes(tool.name);
    }
    if (selectedIntegrations.length > 1) {
      const _allowedTools = allowedTools[tool.integrationName as keyof typeof allowedTools] || [];

      keep = keep 
        && availableIntegrations.includes(tool.integrationName) 
        && (_allowedTools.includes(tool.name) || _allowedTools.includes("*"));
    }
    return keep;
  });
}

export function registerTools({
  server,
  extraTools = [],
  transports,
  selectedIntegrations,
}: {
  server: Server;
  extraTools?: Array<ExtendedTool>;
  transports: Record<string, TransportPayload>;
  selectedIntegrations: string[];
}) {
  server.registerCapabilities({
    tools: {
      listChanged: true,
    },
  });

  server.setRequestHandler(
    ListToolsRequestSchema,
    async (_params, { sessionId }) => {
      if (!sessionId || !transports[sessionId]) {
        throw new Error(`No session found by ID: ${sessionId}`);
      }
      const sessionData = transports[sessionId];

      if (sessionData.cachedTools) {
        return { tools: sessionData.cachedTools };
      }

      const filteredTools = await getAndProcessTools(sessionData.currentJwt, extraTools, selectedIntegrations);
      transports[sessionId].cachedTools = filteredTools;
      return { tools: filteredTools };
    }
  );

  server.setRequestHandler(
    CallToolRequestSchema,
    async (request, { sessionId }) => {
      if (!sessionId || !transports[sessionId]) {
        throw new Error(`No session found by ID: ${sessionId}`);
      }
      const { name, arguments: args } = request.params;
      const sessionData = transports[sessionId];
      if (!sessionData.cachedTools) {
        sessionData.cachedTools = await getAndProcessTools(sessionData.currentJwt, extraTools);
      }
      const dynamicTools = sessionData.cachedTools;
      const tool = dynamicTools.find((t) => t.name === name);
      if (!tool) {
        throw new Error(`Tool not found: ${name}`);
      }

      try {
        const validate = ajv.compile(tool.inputSchema);
        const valid = validate(args);

        if (!valid) {
          return {
            content: [
              {
                type: "text" as const,
                text: JSON.stringify({
                  error: "Validation error",
                  details: validate.errors,
                }),
              },
            ],
            isError: true,
          };
        }

        let response;
        if (tool.isOpenApiTool) {
          response = await performOpenApiAction(
            tool,
            args as { params: any; body: any },
            transports[sessionId].currentJwt
          );
        } else if (tool.name === "CALL_API_REQUEST") {
          response = await performProxyApiRequest(
            args as ProxyApiRequestToolArgs,
            transports[sessionId].currentJwt
          );
        } else {
          response = await performAction(
            tool.name,
            args,
            transports[sessionId].currentJwt
          );
        }

        if (response === null) {
          return {
            content: [
              {
                type: "text" as const,
                text: JSON.stringify({
                  error: `Failed to execute tool: ${tool.name}`,
                }),
              },
            ],
            isError: true,
          };
        }

        return {
          content: [{ type: "text" as const, text: JSON.stringify(response) }],
        };
      } catch (error: any | JsonResponseError | UserNotConnectedError) {
        if (error instanceof UserNotConnectedError) {
          let setupUrl;
          try {
            let userId = decodeJwt(transports[sessionId!].currentJwt)?.payload
              .sub as string;
            if (!userId) {
              throw new Error("User ID not found");
            }
            setupUrl = await generateSetupLink({
              ...error.jsonResponse.meta,
              integrationName:
                tool.name === "CALL_API_REQUEST"
                  ? (args as ProxyApiRequestToolArgs).integration
                  : tool.integrationName,
              userId,
            });

            return {
              content: [
                {
                  type: "text",
                  text: "The integration is not enabled for the user. To set it up, the user will need to visit:",
                },
                {
                  type: "text",
                  text: `${setupUrl}`,
                },
                {
                  type: "text",
                  text: `Instruct the user to set up their ${tool.integrationName} integration by visiting the link. Format the setup link in Markdown.`,
                },
              ],
              isError: true,
            };
          } catch (generateError) {
            error = generateError;
          }
        }

        return {
          content: [
            {
              type: "text" as const,
              text: JSON.stringify({
                error: error.message,
              }),
            },
          ],
          isError: true,
        };
      }
    }
  );
}
